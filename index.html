<html>

<head>
<title> Friend Mapper!</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<link href="style.css" rel="stylesheet" type="text/css"/>

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>

<script id="shader-box-vs" type="x-shader/x-vertex">
attribute vec3 aVertexPosition;
attribute vec4 aVertexColor;

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;

varying vec4 vColor;

void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    vColor = aVertexColor;
}
</script>

<script id="shader-box-fs" type="x-shader/x-fragment">
precision mediump float;

varying vec4 vColor;

void main(void) {
    gl_FragColor = vColor;
}

</script>


<script id="shader-atmosphere-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    varying vec3 vNormal;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

        vec3 transformedNormal = uNMatrix * aVertexNormal;
        vNormal = transformedNormal;
}
</script>

<script id="shader-atmosphere-fs" type="x-shader/-fragment">
    precision mediump float;

    varying vec3 vNormal;

    void main(void) {
        float intensity = 1.05 - dot(vNormal,vec3(0,0,1));
        vec3 atmosphere = vec3(1,1,1) * pow(intensity,3.0);
        gl_FragColor = vec4(atmosphere,1);

    }

</script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec3 vLightWeighting;
    varying vec3 vNormal;

    uniform sampler2D uSampler;

    void main(void) {
        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        float intensity = 1.05 - dot(vNormal,vec3(0,0,1));
        vec3 atmosphere = vec3(1,1,1) * pow(intensity,3.0);
        //gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
        gl_FragColor = vec4(textureColor.rgb * vLightWeighting + atmosphere, textureColor.a);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    uniform vec3 uAmbientColor;

    uniform vec3 uLightingDirection;
    uniform vec3 uDirectionalColor;

    uniform bool uUseLighting;

    varying vec2 vTextureCoord;
    varying vec3 vLightWeighting;
    varying vec3 vNormal;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;

        if (!uUseLighting) {
            vLightWeighting = vec3(1.0, 1.0, 1.0);
        } else {
            vec3 transformedNormal = uNMatrix * aVertexNormal;
            vNormal = transformedNormal;
            float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
        }
    }
</script>


<script type="text/javascript">

var gl;
$j = jQuery.noConflict();

//globals
var animateArcList = [];
var drawArcList = [];
var globalColorLookup = {};
var globalColorTaken = {};

var zoomAmount = -6;
var testArc;
var fromGps = {'latitude':37.221519,'longitude':-121.977020};
var toGps = {'latitude':37.22159,'longitude':-76};

/*****************CLASSES*******************/

function arcObj(gpsFrom,gpsTo,baseRadius,startColor,endColor,thickness,maxHeight) {
    this.alternateForStrips = false;
    this.gpsFrom = gpsFrom;
    this.gpsTo = gpsTo;
    this.baseRadius = baseRadius;
    this.startColor = startColor;
    this.endColor = endColor;
    this.isDoneAnimating = false;
    this.thickness = thickness;
    this.divisions = 25;
    this.maxHeight = maxHeight;

    //animate stuff
    this.animateStep = 0;
    this.totalAnimateSteps = null;
    this.animateVertexAmount = 0;

    //find the vectors
    var pos1 = getPosFromGps(gpsFrom);
    var pos2 = getPosFromGps(gpsTo);

    //our vectors are the normalized versions of these
    this.startVec = vec3.create();
    vec3.normalize(pos1,this.startVec);

    this.endVec = vec3.create();
    vec3.normalize(pos2,this.endVec);

    this.crossVec = vec3.create();
    vec3.cross(this.startVec,this.endVec,this.crossVec);
    vec3.normalize(this.crossVec);
    
    //get the total amount of angle between
    var dotProduct = vec3.dot(this.startVec,this.endVec);
    var dotProductNormal = dotProduct / (vec3.length(this.startVec) * vec3.length(this.endVec));

    this.totalTheta = Math.acos(dotProductNormal);
    this.currentTheta = 0;

    //make the buffers
    this.myVertexBuffer = gl.createBuffer();
    this.myNormalBuffer = gl.createBuffer();
    this.myColorBuffer = gl.createBuffer();
    this.myPickBuffer = gl.createBuffer();

    this.myVertices = [];
    this.myNormals = [];
    this.myColors = [];
    this.myPickColors = [];

    //for the picking
    this.uniqueColor = getUniqueColorObject();
    globalColorLookup[this.uniqueColor.cString] = this;
}

arcObj.prototype.initAnimate = function () {
    //ok so the initial animate thing is dependent on the number of divisions
    this.totalAnimateSteps = this.divisions;
    this.animateStep = 0;

    //and then we increment the number of triangles to draw as we are animating

}

arcObj.prototype.animateArc = function() {
    //check in case we got called badly
    if(this.isDoneAnimating)
    {
        return true;
    }
    //ok so i did a bit of refactoring here. animateArc doesn't do any of the complicated
    //math to generate the points, it just decides which points to display.

    //ok so basically we just have two triangles per division, so update that number
    this.animateStep += 1;
    this.animateVertexAmount = this.animateStep * 2;

    //if we are done
    if(this.animateStep == this.totalAnimateSteps)
    {
        //set the right flag and return
        this.isDoneAnimating = true;
        return true;
    }
    //still have more to go
    return false;

}

arcObj.prototype.fixHeightAndWidth = function () {
    //adjust the maxheight and width depending on how long this thing is

    //basically, this is a function of theta. we scale width and height
    //depending on how short or long the thing is

    //ok so basically, we need to scale height up if its bigger and scale it down if
    //its smaller

    //get a number between 0 and 1 for how "long" the arc is
    //the max theta between two vectors on a plane is just pi
    var ourModifier = (this.totalTheta / (Math.PI));

    //now scale between -1 and 1
    var ourDelta = (ourModifier - 0.5) * 2;

    //now scale height
    this.maxHeight = this.maxHeight * 0.05 + this.maxHeight * ourModifier;

    //fix our width too
    this.thickness = this.thickness * 0.1 + this.thickness * ourModifier * 2;

    //also our divisions
    this.divisions = Math.round(200 * ourModifier) + 2;

}

arcObj.prototype.buildArc = function () {
    //this method generates the points and does some house keeping
    this.fixHeightAndWidth();
    this.generateArcPoints();
    //refresh buffers?
    this.refreshBuffers();
    this.initAnimate();
}

arcObj.prototype.generateArcPoints = function () {

    //the idea is that we want to loop through theta with the correct number of
    //divisions and generate those points
    for(var genStep = 0; genStep < this.divisions; genStep++)
    {
        //stupid namespace things @_____@
        this.currentTheta = genStep * this.totalTheta / this.divisions;

        var progress = genStep / (this.divisions - 1);

        //ok so we will just compute the vertices for the current theta, add them, and then

        //first get the current radius
        var heightScaleAmount = Math.sin(progress * Math.PI);
        var thisRadius = this.baseRadius + heightScaleAmount * this.maxHeight;
        
        //first scale appropriately
        var adjVec = vec3.create(this.startVec);
        //these look way better with linear interp and sine-based height
        vec3.scale(adjVec,(1-progress));

        var oppVec = vec3.create(this.endVec);
        vec3.scale(oppVec,progress);

        //add these, normalize, scale by radius
        var thisNormal = vec3.create();
        vec3.add(adjVec,oppVec,thisNormal);
        vec3.normalize(thisNormal);

        var thisPoint = vec3.create();
        vec3.scale(thisNormal,thisRadius,thisPoint);
        
        //also get the point that is "thickness" away in cross direction
        var upperNormal = vec3.create(thisNormal);
        var addVec = vec3.create();
        vec3.scale(this.crossVec,this.thickness * heightScaleAmount,addVec);

        //add the addVec to the normal to get the upper point
        vec3.add(upperNormal,addVec,upperNormal);
        vec3.normalize(upperNormal);

        //get the point also
        var upperPoint = vec3.create(upperNormal);
        vec3.scale(upperPoint,thisRadius);
        
        //add them in the right order!
        var firstVertex;
        var secondVertex;
        var firstNormal;
        var secondNormal;

        //goddamnit webgl give me quad strips and not this shit!!!!
        if(!this.alternateForStrips)
        {
            firstVertex = thisPoint;
            secondVertex = upperPoint;
            firstNormal = thisNormal;
            secondNormal = upperNormal;
        }
        else
        {
            firstVertex = upperPoint;
            secondVertex = thisPoint;
            firstNormal = upperNormal;
            secondNormal = thisNormal;
        }
        //wtf why dont i have to do this?
        //this.alternateForStrips = !this.alternateForStrips;
        
        //these are our points!! yay. add them to the vertices and normals
        this.myVertices.push(firstVertex[0],firstVertex[1],firstVertex[2]);
        this.myNormals.push(firstNormal[0],firstNormal[1],firstNormal[2]);

        //add these points too
        this.myVertices.push(secondVertex[0],secondVertex[1],secondVertex[2]);
        this.myNormals.push(secondNormal[0],secondNormal[1],secondNormal[2]);

        //Colors!!
        var thisColor = [];
        for(var i = 0; i < 4; i++)
        {
            thisColor[i] = this.startColor[i] * Math.cos(this.currentTheta) + 
                            this.endColor[i] * Math.sin(this.currentTheta);
            //try out linear?
            thisColor[i] = this.startColor[i] * (1-progress) +
                            this.endColor[i] * (progress);
        }

        //push the color twice
        this.myColors.push(thisColor[0],thisColor[1],thisColor[2],thisColor[3]);
        this.myColors.push(thisColor[0],thisColor[1],thisColor[2],thisColor[3]);

        //push our unique color twice. dont forget about alpha!
        this.myPickColors.push(this.uniqueColor.rFloat,this.uniqueColor.gFloat,this.uniqueColor.bFloat,1);
        this.myPickColors.push(this.uniqueColor.rFloat,this.uniqueColor.gFloat,this.uniqueColor.bFloat,1);

    }
    //end of loop, we have filled up all of the arrays
    //now we return and selectively draw to animate

}


arcObj.prototype.refreshBuffers = function () {
    //buffer the data

    gl.bindBuffer(gl.ARRAY_BUFFER, this.myVertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.myVertices), gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.myNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.myNormals), gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.myColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.myColors), gl.DYNAMIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, this.myPickBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.myPickColors), gl.DYNAMIC_DRAW);
 
    //update the sizes
    this.myVertexBuffer.itemSize = 3;
    this.myVertexBuffer.numItems = this.myVertices.length / 3;

    this.myColorBuffer.itemSize = 4;
    this.myColorBuffer.numItems = this.myColors.length / 4;

    this.myNormalBuffer.itemSize = 3;
    this.myNormalBuffer.numItems = this.myNormals.length / 3;

    this.myPickBuffer.itemSize = 4;
    this.myPickBuffer.numItems = this.myPickColors.length / 4;

}

arcObj.prototype.drawArcStrips = function() {
    this.drawArcStripsEither(false);
}

arcObj.prototype.drawArcStripsForPicking = function() {
    this.drawArcStripsEither(true);
}

arcObj.prototype.drawArcStripsEither = function(forPicking) {
    //we just need to bind our buffers and then draw!

    //need to bind this vertex buffer
    gl.bindBuffer(gl.ARRAY_BUFFER,this.myVertexBuffer);
    gl.vertexAttribPointer(blendShaderProgram.vertexPositionAttribute,this.myVertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
    //need to bind this color buffer
    if(!forPicking)
    {
        gl.bindBuffer(gl.ARRAY_BUFFER,this.myColorBuffer);
        gl.vertexAttribPointer(blendShaderProgram.vertexColorAttribute, this.myColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
    }
    else
    {
        gl.bindBuffer(gl.ARRAY_BUFFER,this.myPickBuffer);
        gl.vertexAttribPointer(blendShaderProgram.vertexColorAttribute, this.myPickBuffer.itemSize, gl.FLOAT, false, 0, 0);
    }

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, this.animateVertexAmount);
}


/***************End Classes!*****************************/


/********** Geometry Functions *******/

function getPosFromGps(gpsCoords)
{
    //gives you the position on the sphere (sans radius) from a gps location
    var lat = gpsCoords.latitude;
    var long = gpsCoords.longitude;

    var latRad = lat * Math.PI / 180;
    var longRad = long * Math.PI / 180;

    var theta = Math.PI/2 - latRad;
    var phi = Math.PI - longRad;

    var x = Math.cos(phi) * Math.sin(theta);
    var y = Math.cos(theta);
    var z = Math.sin(phi) * Math.sin(theta);

    var returnVec = vec3.create([x,y,z]);
    return returnVec;
}

function myColorRand() {
    return Math.round(Math.random() * 255);
}

function zeroPad(num,count)
{
    var numZeropad = String(num);
    while(numZeropad.length < count) {
        numZeropad = "0" + numZeropad;
    }
    return numZeropad;
}

function getRandomColor() {
    var r = myColorRand(); var rS = zeroPad(r,3);
    var g = myColorRand(); var gS = zeroPad(g,3);
    var b = myColorRand(); var bS = zeroPad(b,3);
    var rFloat = r / 255;
    var gFloat = g / 255;
    var bFloat = b / 255;
    
    var cString = rS + gS + bS;

    return {'r':r,'g':g,'b':b,'cString':cString,
            'rFloat':rFloat,'gFloat':gFloat,'bFloat':bFloat};
}

function getUniqueColorObject()
{
    //make a color object that doesnt exist, and go store it
    var aColor = getRandomColor();
    while(globalColorTaken[aColor.cString])
    {
        aColor = getRandomColor();
    }
    //ready for return
    globalColorTaken[aColor.cString] = true;
    return aColor;
}


/*******************Geometry Functions******************/

function initGL(canvas) {
    try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
    } catch (e) {
    }
    if (!gl) {
        alert("Could not initialise WebGL, sorry :-(");
    }
}

function onMouseWheel(event) {

    event.preventDefault();

    zoomAmount += event.wheelDeltaY * 0.003;



}

function resizeWindow()
{
    //TODO: fix the width and height of the frame buffer

    //window sizes
    var wHeight = $j(window).height();
    var wWidth = $j(window).width();

    //viewport sizes
    vHeight = wHeight;
    vWidth = wWidth;

    //set the width to the canvas
    $j('#earth-canvas').attr('width',String(vWidth) + 'px');
    $j('#earth-canvas').attr('height',String(vHeight) + 'px');

    gl.viewportWidth = vWidth;
    gl.viewportHeight = vHeight; 
    gl.viewport(0,0,vWidth,vHeight);

    mat4.perspective(45,gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

    setMatrixUniforms();
}


function getShader(gl, id) {
    var shaderScript = document.getElementById(id);
    if (!shaderScript) {
        return null;
    }

    var str = "";
    var k = shaderScript.firstChild;
    while (k) {
        if (k.nodeType == 3) {
            str += k.textContent;
        }
        k = k.nextSibling;
    }

    var shader;
    if (shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
        return null;
    }

    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
}

//global colors
var ambientR = 0.5;
var ambientG = 0.7;
var ambientB = 1.2;

var lDirectionX = -1.0;
var lDirectionY = -1.0;
var lDirectionZ = -1.0;

var lightingDirection = [
    lDirectionX,
    lDirectionY,
    lDirectionZ
];

var lColorR = 0.8;
var lColorG = 0.8;
var lColorB = 0.8;

var earthShaderProgram;
var blendShaderProgram;

function initShaders() {
    //earth shader
    var fragmentShader = getShader(gl, "shader-fs");
    var vertexShader = getShader(gl, "shader-vs");

    //atmosphere shader
    var atmosphereVertexShader = getShader(gl,"shader-atmosphere-vs");
    var atmosphereFragShader = getShader(gl,"shader-atmosphere-fs");

    //box shadeer
    var blendVertexShader = getShader(gl, "shader-box-vs");
    var blendFragShader = getShader(gl, "shader-box-fs");

    earthShaderProgram = gl.createProgram();
    gl.attachShader(earthShaderProgram, vertexShader);
    gl.attachShader(earthShaderProgram, fragmentShader);
    gl.linkProgram(earthShaderProgram);

    blendShaderProgram = gl.createProgram();
    gl.attachShader(blendShaderProgram, blendVertexShader);
    gl.attachShader(blendShaderProgram, blendFragShader);
    gl.linkProgram(blendShaderProgram);

    if (!gl.getProgramParameter(earthShaderProgram, gl.LINK_STATUS) || 
            !gl.getProgramParameter(blendShaderProgram, gl.LINK_STATUS)){
        alert("Could not initialise shaders");
    }

    gl.useProgram(earthShaderProgram);

    earthShaderProgram.vertexPositionAttribute = gl.getAttribLocation(earthShaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(earthShaderProgram.vertexPositionAttribute);

    earthShaderProgram.textureCoordAttribute = gl.getAttribLocation(earthShaderProgram, "aTextureCoord");
    gl.enableVertexAttribArray(earthShaderProgram.textureCoordAttribute);

    earthShaderProgram.vertexNormalAttribute = gl.getAttribLocation(earthShaderProgram, "aVertexNormal");
    gl.enableVertexAttribArray(earthShaderProgram.vertexNormalAttribute);

    earthShaderProgram.pMatrixUniform = gl.getUniformLocation(earthShaderProgram, "uPMatrix");
    earthShaderProgram.mvMatrixUniform = gl.getUniformLocation(earthShaderProgram, "uMVMatrix");
    earthShaderProgram.nMatrixUniform = gl.getUniformLocation(earthShaderProgram, "uNMatrix");
    earthShaderProgram.samplerUniform = gl.getUniformLocation(earthShaderProgram, "uSampler");
    earthShaderProgram.useLightingUniform = gl.getUniformLocation(earthShaderProgram, "uUseLighting");
    earthShaderProgram.ambientColorUniform = gl.getUniformLocation(earthShaderProgram, "uAmbientColor");
    earthShaderProgram.lightingDirectionUniform = gl.getUniformLocation(earthShaderProgram, "uLightingDirection");
    earthShaderProgram.directionalColorUniform = gl.getUniformLocation(earthShaderProgram, "uDirectionalColor");

    //our arcs
    gl.useProgram(blendShaderProgram);

    blendShaderProgram.vertexPositionAttribute = gl.getAttribLocation(blendShaderProgram,"aVertexPosition");
    gl.enableVertexAttribArray(blendShaderProgram.vertexPositionAttribute);

    blendShaderProgram.vertexColorAttribute = gl.getAttribLocation(blendShaderProgram,"aVertexColor");
    gl.enableVertexAttribArray(blendShaderProgram.vertexColorAttribute);

    blendShaderProgram.pMatrixUniform = gl.getUniformLocation(blendShaderProgram,"uPMatrix");
    blendShaderProgram.mvMatrixUniform = gl.getUniformLocation(blendShaderProgram,"uMVMatrix");

    gl.useProgram(earthShaderProgram);
}


function handleLoadedTexture(texture) {
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
    gl.generateMipmap(gl.TEXTURE_2D);

    gl.bindTexture(gl.TEXTURE_2D, null);
}


var earthTexture;

var otherFramebuffer;
var otherTexture;

function initOtherFrameBuffer() {
    //make frame buffer
    otherFramebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER,otherFramebuffer);
    otherFramebuffer.width = $j(window).width();
    otherFramebuffer.height = $j(window).height();

    //make texture
    otherTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, otherTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
    gl.generateMipmap(gl.TEXTURE_2D);

    //set it to rgba
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, otherFramebuffer.width, otherFramebuffer.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    //something with a render buffer?
    var renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER,renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, otherFramebuffer.width, otherFramebuffer.height);

    //for texture? set attached depth buffer also?
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, otherTexture, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

    //reset back to default
    gl.bindTexture(gl.TEXTURE_2D,null);
    gl.bindRenderbuffer(gl.RENDERBUFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
}

function initTexture() {
    earthTexture = gl.createTexture();
    earthTexture.image = new Image();
    earthTexture.image.onload = function () {
        handleLoadedTexture(earthTexture)
    }

    //earthTexture.image.src = "http://localhost/lesson11/world.jpg";
    earthTexture.image.src = "world.jpg";
}

var mvMatrix = mat4.create();
var mvMatrixStack = [];
var pMatrix = mat4.create();

function mvPushMatrix() {
    var copy = mat4.create();
    mat4.set(mvMatrix, copy);
    mvMatrixStack.push(copy);
}

function mvPopMatrix() {
    if (mvMatrixStack.length == 0) {
        throw "Invalid popMatrix!";
    }
    mvMatrix = mvMatrixStack.pop();
}

function setMatrixUniforms() {
    gl.uniformMatrix4fv(earthShaderProgram.pMatrixUniform, false, pMatrix);
    gl.uniformMatrix4fv(earthShaderProgram.mvMatrixUniform, false, mvMatrix);

    gl.uniformMatrix4fv(blendShaderProgram.pMatrixUniform, false, pMatrix);
    gl.uniformMatrix4fv(blendShaderProgram.mvMatrixUniform, false, mvMatrix);

    var normalMatrix = mat3.create();
    mat4.toInverseMat3(mvMatrix, normalMatrix);
    mat3.transpose(normalMatrix);
    gl.uniformMatrix3fv(earthShaderProgram.nMatrixUniform, false, normalMatrix);
    gl.uniformMatrix3fv(earthShaderProgram.nMatrixUniform, false, normalMatrix);
}


function degToRad(degrees) {
    return degrees * Math.PI / 180;
}


var mouseDown = false;
var lastMouseX = null;
var lastMouseY = null;

var earthRotationMatrix = mat4.create();
mat4.identity(earthRotationMatrix);

function handleMouseDown(event) {
    mouseDown = true;
    lastMouseX = event.clientX;
    lastMouseY = event.clientY;
}


function handleMouseUp(event) {
    mouseDown = false;
}


function handleMouseMove(event) {
    if (!mouseDown) {
        return;
    }
    var newX = event.clientX;
    var newY = event.clientY;

    var deltaX = newX - lastMouseX;
    var newRotationMatrix = mat4.create();
    mat4.identity(newRotationMatrix);
    mat4.rotate(newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);

    var deltaY = newY - lastMouseY;
    mat4.rotate(newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);

    mat4.multiply(newRotationMatrix, earthRotationMatrix, earthRotationMatrix);

    lastMouseX = newX
    lastMouseY = newY;
}



var earthVertexPositionBuffer;
var earthVertexNormalBuffer;
var earthVertexTextureCoordBuffer;
var earthVertexIndexBuffer;

var boxVertexPositionBuffer;
var boxVertexColorBuffer;

var vertices;
var colors;

function initEarthBuffers() {
    var latitudeBands = 30;
    var longitudeBands = 30;
    var radius = 2;

    var vertexPositionData = [];
    var normalData = [];
    var textureCoordData = [];
    for (var latNumber=0; latNumber <= latitudeBands; latNumber++) {
        var theta = latNumber * Math.PI / latitudeBands;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta);

        for (var longNumber=0; longNumber <= longitudeBands; longNumber++) {
            var phi = longNumber * 2 * Math.PI / longitudeBands;
            var sinPhi = Math.sin(phi);
            var cosPhi = Math.cos(phi);

            var x = cosPhi * sinTheta;
            var y = cosTheta;
            var z = sinPhi * sinTheta;

            var u = 1 - (longNumber / longitudeBands);
            var v = 1 - (latNumber / latitudeBands);

            var xSquared = Math.pow(x,2);
            var ySquared = Math.pow(y,2);
            var zSquared = Math.pow(z,2);
            var mag = Math.sqrt(xSquared + ySquared + zSquared);

            normalData.push(x);
            normalData.push(y);
            normalData.push(z);

            textureCoordData.push(u);
            textureCoordData.push(v);

            vertexPositionData.push(radius * x);
            vertexPositionData.push(radius * y);
            vertexPositionData.push(radius * z);
        }
    }

    var indexData = [];
    for (var latNumber=0; latNumber < latitudeBands; latNumber++) {
        for (var longNumber=0; longNumber < longitudeBands; longNumber++) {
            var first = (latNumber * (longitudeBands + 1)) + longNumber;
            var second = first + longitudeBands + 1;
            indexData.push(first);
            indexData.push(second);
            indexData.push(first + 1);

            indexData.push(second);
            indexData.push(second + 1);
            indexData.push(first + 1);
        }
    }

    earthVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, earthVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalData), gl.STATIC_DRAW);
    earthVertexNormalBuffer.itemSize = 3;
    earthVertexNormalBuffer.numItems = normalData.length / 3;

    earthVertexTextureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, earthVertexTextureCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordData), gl.STATIC_DRAW);
    earthVertexTextureCoordBuffer.itemSize = 2;
    earthVertexTextureCoordBuffer.numItems = textureCoordData.length / 2;

    earthVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, earthVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
    earthVertexPositionBuffer.itemSize = 3;
    earthVertexPositionBuffer.numItems = vertexPositionData.length / 3;

    earthVertexIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, earthVertexIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
    earthVertexIndexBuffer.itemSize = 1;
    earthVertexIndexBuffer.numItems = indexData.length;

}

function initArcBuffers() {

    var radius = 2;
    //for box
    boxVertexPositionBuffer = gl.createBuffer();

    var lat = 37.221519;
    var long = -121.977020;

    console.log("Lat is " + lat);
    console.log("Long is " + long);

    var latRad = lat * Math.PI / 180;
    var longRad = long * Math.PI / 180;

    var theta = Math.PI/2 - latRad;
    var phi = Math.PI - longRad;

    console.log("Phi is " + phi);
    console.log("theta is " + theta);

    var x = Math.cos(phi) * Math.sin(theta) * radius;
    var y = Math.cos(theta) * radius;
    var z = Math.sin(phi) * Math.sin(theta) * radius;

    vertices = [
        x, y, z,
        x*2, y*2, z*2,
        2, -2, 0,
        2, 2, 0
    ];

    gl.bindBuffer(gl.ARRAY_BUFFER, boxVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
    boxVertexPositionBuffer.itemSize = 3;
    boxVertexPositionBuffer.numItems = 4;

    boxVertexColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, boxVertexColorBuffer);
    colors = [
        1, 0, 0, 1,
        1, 0, 0, 1,
        1, 1, 1, 1,
        1, 1, 1, 1
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.DYNAMIC_DRAW);
    boxVertexColorBuffer.itemSize = 4;
    boxVertexColorBuffer.numItems = 4;

}

function refreshArcBuffers()
{
    gl.bindBuffer(gl.ARRAY_BUFFER, boxVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.DYNAMIC_DRAW);
    boxVertexPositionBuffer.itemSize = 3;
    boxVertexPositionBuffer.numItems = vertices.length / 3;

    gl.bindBuffer(gl.ARRAY_BUFFER, boxVertexColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.DYNAMIC_DRAW);
    boxVertexColorBuffer.itemSize = 4;
    boxVertexColorBuffer.numItems = colors.length / 4;
}

function drawArcs() {

    gl.useProgram(blendShaderProgram);

    gl.bindBuffer(gl.ARRAY_BUFFER,boxVertexPositionBuffer);
    gl.vertexAttribPointer(blendShaderProgram.vertexPositionAttribute,boxVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER,boxVertexColorBuffer);
    gl.vertexAttribPointer(blendShaderProgram.vertexColorAttribute, boxVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
    setMatrixUniforms();
}

function drawScene() {

    cameraPerspectiveClear();
    lighting();
    translateAndRotate();
    drawEarth();
    refreshArcBuffers();
    drawArcs();

    setMatrixUniforms();
    gl.useProgram(blendShaderProgram);

    testArc.animateArc();
    testArc.drawArcStrips();

    //animate all the arcs if necessary
    for(var i = 0; i < animateArcList.length; i++)
    {
        var response = animateArcList[i].animateArc();
        //if the arc is done animating, remove it
        if(response)
        {
            //remove from this list
            animateArcList.splice(i,1);
            i--;
        }
    }

    for(var i = 0; i < drawArcList.length; i++)
    {
        //draw the arc
        drawArcList[i].drawArcStrips();
        //drawArcList[i].drawArcStripsForPicking();
    }

}

function randomGps() {
    var lat = Math.random() * 180 + -90;
    var long = Math.random() * 360 - 180;

    return {'latitude':lat,'longitude':long};

}

function rubberBandBall() {
    for(var i = 0; i < 50; i++) { generateRandomArc(); }
}

function generateRandomArc() {
    var fromGps = randomGps();
    var toGps = randomGps();

    var thisArc = new arcObj(fromGps,toGps,2,[0,0,1,1],[1,1,1,1],0.04,0.1);
    thisArc.buildArc();

    animateArcList.push(thisArc);
    drawArcList.push(thisArc);
}

function testBigArc() {
    var asd = -80;
    var fromGps = {'latitude':0,'longitude':asd};
    var toGps = {'latitude':0,'longitude':90};

    var thisArc = new arcObj(fromGps,toGps,2,[0,1,0,1],[0,0,1,1],0.04,0.1);
    thisArc.buildArc();
    animateArcList.push(thisArc);
    drawArcList.push(thisArc);
}

function cameraPerspectiveClear() {

    gl.useProgram(earthShaderProgram);
    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);

    //we set our clearColor to be 0 0 0 0, so its essentially transparent.
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
}

function lighting() {

    //legacy
    var lighting = true;
    gl.uniform1i(earthShaderProgram.useLightingUniform, lighting);

    if (lighting) {
        gl.uniform3f(
            earthShaderProgram.ambientColorUniform,
            ambientR,
            ambientG,
            ambientB
        );

        var adjustedLD = vec3.create();
        vec3.normalize(lightingDirection, adjustedLD);
        vec3.scale(adjustedLD, -1);
        gl.uniform3fv(earthShaderProgram.lightingDirectionUniform, adjustedLD);

        gl.uniform3f(
            earthShaderProgram.directionalColorUniform,
            lColorR,
            lColorG,
            lColorB
        );
    }

}

function translateAndRotate() {

    mat4.identity(mvMatrix);

    mvPushMatrix();

    mat4.translate(mvMatrix, [0, 0, zoomAmount]);

    mat4.multiply(mvMatrix, earthRotationMatrix);
    setMatrixUniforms();
}

function drawEarth() {

    gl.useProgram(earthShaderProgram);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, earthTexture);
    gl.uniform1i(earthShaderProgram.samplerUniform, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, earthVertexPositionBuffer);
    gl.vertexAttribPointer(earthShaderProgram.vertexPositionAttribute, earthVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, earthVertexTextureCoordBuffer);
    gl.vertexAttribPointer(earthShaderProgram.textureCoordAttribute, earthVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, earthVertexNormalBuffer);
    gl.vertexAttribPointer(earthShaderProgram.vertexNormalAttribute, earthVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, earthVertexIndexBuffer);
    gl.drawElements(gl.TRIANGLES, earthVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

}


//slowly rotate
function slowRotate()
{
    var rMatrix = mat4.create();
    mat4.identity(rMatrix);
    mat4.rotate(rMatrix,degToRad(0.1),[0,1,0]);

    mat4.multiply(rMatrix,earthRotationMatrix,earthRotationMatrix);
}

function tick() {
    requestAnimFrame(tick);
    drawScene();
    slowRotate();
}


function webGLStart() {
    var canvas = document.getElementById("earth-canvas");
    initGL(canvas);
    initShaders();
    initEarthBuffers();
    initArcBuffers();
    initTexture();
    initOtherFrameBuffer();

    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.enable(gl.DEPTH_TEST);

    document.onmousedown = handleMouseDown;
    document.onmouseup = handleMouseUp;
    document.onmousemove = handleMouseMove;

    testArc = new arcObj(fromGps,toGps,2,[1,1,1,1],[0,0,1,1],0.05,0.1);
    testArc.buildArc();

    tick();
}

$j(document).ready(function(){
    webGLStart();

    $j(window).resize(function(){resizeWindow();});
    //initial resize
    resizeWindow();

    var container = document.getElementById('earth-canvas');
    container.addEventListener('mousewheel',onMouseWheel,false);

});

</script>


</head>


<body>
 <div id="fb-root"></div>
<script>

//fblobals

//just holds the about me part
var meObject = null;
//all your friends by id
var globalFriendDict = {};
//all the locations so far by id
var globalLocationDict = {};
//all the places so far by id
var globalPlaceDict = {};

//the login response
var fbLoginResponse = null;


window.fbAsyncInit = function() {
    FB.init({
      appId      : '246595098746259', // App ID
      channelUrl : '//www.petermcottle.com/channel.html', // Channel File
      status     : true, // check login status
      cookie     : true, // enable cookies to allow the server to access the session
      xfbml      : true,  // parse XFBML
      oatuh      : true,
    });

    // Additional initialization code here
    initFacebook();

  };

  // Load the SDK Asynchronously
  (function(d){
     var js, id = 'facebook-jssdk'; if (d.getElementById(id)) {return;}
     js = d.createElement('script'); js.id = id; js.async = true;
     js.src = "//connect.facebook.net/en_US/all.js";
     d.getElementsByTagName('head')[0].appendChild(js);
   }(document));

function fbTest() {
    FB.api('/me', function(response) {console.log(response);alert("your name is " + response.name); });
}

function fbLogin() {
    FB.login(function(response)
    {
        if(response.authResponse) {

            console.log(response.authResponse);
            fbLoginResponse = response;

            removeAuthButton();
            launchFbAvalanche();

         } else {
             alert("You denied me");
         }
    },{scope:'user_about_me,friends_hometown,friends_location,friends_education_history,friends_work_history,friends_about_me,user_location,user_work_history,user_hometown,user_education_history'});
}

function removeAuthButton() {
    $j('#authBox').fadeOut();

}

function handleFriendsBack(response) {
    console.log("Friends back");
    console.log(response);

    if(response.friends.paging && response.friends.paging.next)
    {
        var pagingLink = response.friends.paging.next;
        //TODO: do the paging... I'm not sure if this is necessary :O
    }

    //loop through these friends
    var friendList = response.friends.data;

    //RATE LIMIT: fix not only first 3 friends
    for(var i = 0; i < friendList.length; i++)
    //for(var i =0; i < 10; i++)
    {
        var friend = friendList[i];

        var fId = friend.id;
        var fName = friend.name;

        //store this in the global friend dict
        globalFriendDict[fId] = friend;

        //fire off a request for this friend, and a function to handle it
        FB.api('/' + fId + '?fields=id,about,name,hometown,location,work,education',function(response){ handleFriendBack(response); });
    }
}

function handleFriendBack(response){
    console.log("Individual friend back");
    console.log(response);

    //if auth failed for some reason... like mid-session
    //im sure theres a better way to do this
    if(!response.name)
    {
        return;
    }

    var id = response.id;
    //overwrite with this updated one with location and everything
    globalFriendDict[id] = response;

    //heres the deal. We will basically go ahead and directly graph
    //this connection, except for when we have no location GPS, in which case
    //we will go query that location GPS and add it to the todo list
    if(response.hometown)
    {
        //add this location and either query or graph
        var hometownId = response.hometown.id;

        //if its already in here
        if(globalLocationDict[hometownId])
        {
            //if we have this hometown location, just go graph it
            if(globalLocationDict[hometownId].location)
            {
                graphFriendRelationship('hometown',response.id);
            }
            else //we are in the middle of a query and this will come back but not yet...
            {
                //add it to the todolist
                globalLocationDict[hometownId].todoList.push( function() {
                        graphFriendRelationship('hometown',response.id);
                    });
            }
        }
        else
        {
            //definitely not in there, so add it first
            globalLocationDict[hometownId] = response.hometown;
            globalLocationDict[hometownId].todoList = [];
            //add our graph to the todolist
            globalLocationDict[hometownId].todoList.push(function() {
                    graphFriendRelationship('hometown',response.id);
                });
            //go query it
            getLocationDetails(hometownId);
        }
    }//end of hometown check
    else
    {
        console.log("Friend " + response.name + " didnt list their hometown!");
    }
}

function getLocationDetails(locationId)
{
    //hopefully the fb api has the location already, in which case this is easy!
    FB.api('/' + locationId, function(response) { locationDeetsCb(response); });
}

function locationDeetsCb(response)
{
    //dont overwrite our todolist but update everything else
    //this is bad design :-/
    var theId = response.id;
    for(key in response)
    {
        //add in each piece of data
        globalLocationDict[theId][key] = response[key];
    }

    //if theres no gps here
    if(!response.location)
    {
        alert("A location came back with no gps coords! uh oh");
    }
    else
    {
        //go through our todolist and process them
        var ourTodoList = globalLocationDict[theId].todoList;
        for(var i = 0; i < ourTodoList.length; i++)
        {
            //call that function whatever it was
            ourTodoList[i]();
        }
    }
}

function findGPS(locationId)
{
    //honestly there are two ways to do this. either via facebook graph search
    //or via YQL which I have always liked

}

function graphFriendRelationship(relationshipType,friendId)
{
    console.log('graphing relationship of ' + relationshipType + ' between you and friend ' + globalFriendDict[friendId].name);
    var locationId = globalFriendDict[friendId][relationshipType].id;
    var locationGPS = globalLocationDict[locationId].location;
    console.log("gps is " + locationGPS.latitude + " " + locationGPS.longitude);


    //if we have a hometown
    if(meObject.hometown && meObject.hometown.id && globalLocationDict[meObject.hometown.id].location)
    {
        var fromGps = globalLocationDict[meObject.hometown.id].location;
        var toGps = locationGPS;
        //make a new arc and add it
        var thisArc = new arcObj(fromGps,toGps,2,[0,0,1,1],[1,1,1,1],0.04,0.1);
        //do all the math
        thisArc.buildArc();

        //we will animate
        animateArcList.push(thisArc);
        //we want to draw it too
        drawArcList.push(thisArc);
    }
    else
    {
        console.log('no hometown yet');
    }
}

function launchFbAvalanche() {

    //short circuit
    return;
    console.log(fbLoginResponse);
    console.log("***********You're logged in!***************");

    //do a query for your friends
    FB.api('/me?fields=friends',handleFriendsBack);
    //get yourself too
    FB.api('/me',handleMeBack);
}

function handleMeBack(response){
    console.log("me back");
    console.log(response);
    meObject = response;
    //TODO: graph me connections
    if(response.hometown)
    {
       var hometownId = response.hometown.id;
       globalLocationDict[response.hometown.id] = response.hometown;
       globalLocationDict[hometownId].todoList = [];
       globalLocationDict[hometownId].todoList.push(function() {
           console.log("Your hometown back!!");
           console.log(globalLocationDict[hometownId].location);
        });
       getLocationDetails(hometownId);
    }
    else
    {
        alert("You haven't listed a hometown on Facebook!");
    }
}

function askForAuth() {
    //add that button thing
    $j('body').append('<div id="authBox"style="position:absolute;top:0px;left:0px;width:200px;height:200px;background:white;"><font style="color:black"><a style="color:black;cursor:pointer"onclick="javascript:fbLogin()">Please authenticate the app!</a></font></div>');
}

function initFacebook(){
    //async check for logged in status
    FB.getLoginStatus(function(response) {
        if(response.status == 'connected')
        {
            //we are good to go, store this and go!
            fbLoginResponse = response;
            launchFbAvalanche();
        }
        else if (response.status == 'not_authorized')
        {
            //ask them to authenticate
            askForAuth();
        }
        else
        {
            //not even logged in
            askForAuth();
        }
    });
}

</script>

    <canvas id="earth-canvas" style="border: none;" width="500px" height="500px"></canvas>

</body>

</html>
